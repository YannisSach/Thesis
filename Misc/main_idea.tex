\documentclass[a4paper,10pt]{article}
\usepackage[a4paper, total={6in, 8in}]{geometry}

\usepackage[utf8]{inputenc}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{graphicx}

\graphicspath{{/home/yannis/Thesis/img/}}



\lstset{
   breaklines=true,}


\title{Evaluation of rejected-bpor}

\date{}

\begin{document}

\maketitle

\section*{Comparing Bpor with Source-bpor}

\subsection*{The algorithm used for both source-dpor and dpor}

We present the algorithm that is used to add a branch at a certain point.

In the following routine, variable i represents the point where the branch will be added, j represents the last command that has
been executed by the trace and the boolean variable is-conservative represents whether the branch will be conservative or not.

This routine is used in all algorithms (source, dpor, source-bpor, bpor, rejected-bpor) implemented in nidhugg for the sequential consistency memory
model. When the persistent sets are used the variable source-sets-enabled is set false.

The bpor algorithm is the algorithm described in the bpor paper. \\
The source-bpor uses source-sets when it adds non-conservative branches and persistent-sets when it adds conservative branches. 
We have showed source-sets are not enough for conservative sets as they lead to non-sound coverage of the state space.\\

\begin{verbatim}

add_branch(int i, int j, bool is_conservative){

  VecSet<IPid> isleep = sleep_set_at(i);
  
  /* candidates is a map from IPid p to event index i such that the
   * IID (p,i) identifies an event between prefix[i] (exclusive) and
   * prefix[j] (inclusive) such that (p,i) does not happen-after any
   * other IID between prefix[i] (inclusive) and prefix[j]
   * (inclusive).
   *
   * If no such event has yet been found for a thread p, then
   * candidates[p] is out of bounds, or has the value -1.
   */

  std::vector<int> candidates;
  Branch cand = {-1,0,is_conservative};
  const VClock<IPid> &iclock = prefix[i].clock;
  const VClock<IPid> &jclock = prefix[j].clock;
  Branch previous = cand;

  bool rejected = false;
  int start = i+1;
  bool keep_rejected = conf.preem_method == Configuration::RBPOR;
  for(int k = start; k <= j; ++k){
    IPid p = prefix[k].iid.get_pid();
    /* Did we already cover p? */
    if(p < int(candidates.size()) && 0 <= candidates[p]) continue;
    const VClock<IPid> &pclock = prefix[k].clock;
    /* Is p after prefix[i]? */
      if (k != j && iclock.leq(pclock))
        continue;

      /* Is p after some other candidate? */
      bool is_after = false;
      for (int q = 0; !is_after && q < int(candidates.size()); ++q)
      {
        if (0 <= candidates[q] && candidates[q] <= pclock[q])
        {
          is_after = true;
        }
      }
      if (is_after)
        continue;
    if(int(candidates.size()) <= p){
      candidates.resize(p+1,-1);
    }
    previous = cand;
    candidates[p] = prefix[k].iid.get_index();
    cand.pid = p;

    /* In this if statemenent lies the difference between source DPOR and persistent 
    */
    if(prefix[i].branch.count(cand)){ //|| prefix[i].branch.count({cand.pid,cand.alt,!(cand.is_conservative)})){
      /* There is already a satisfactory candidate branch */
       int bid = prefix[i].branch.find(cand);
       /* Update the conservative branches with the non conservative ones.
        */

       if(prefix[i].branch[bid].is_conservative){
         if(cand.is_conservative && !is_conservative){
           prefix[i].branch.insert(cand);
         }
       }
      /* Don't try to consider this candidate as conservative branch
       */
       if(!source_sets_enabled || is_conservative){
         if(jclock.includes(prefix[k].iid) || cand.pid == prefix[j].iid.get_pid()){
           return;
         }
         if(keep_rejected && !is_conservative){
           rejected = true;
         }
         continue;
       }
       return;
    }


    /* Be more strict with conservative branches.
     * Reject a branch if it is already in the conservative set.
     */
    // added is_conservative at the beggining..
    if(