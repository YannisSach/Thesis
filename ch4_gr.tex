\chapter{Αξιολόγηση των Υλοποιηθέντων Αλγορίθμων}
\label{Chapter 4}

Σε αυτό το κεφάλαιο η επίδοση κάθε αλγορίθμου που υλοποιήθηκε αξιολογείται. Αρχικά μελετάμε την επίδοσου του 
Nidhugg-DPOR προκειμένου να δείξουμε ότι και στην υλοποίηση μας πράγματι η επίδοσήτ του διαφέρει από αυτή του Source-DPOR. Η
αξιολόγηση χωρίζεται σε δύο μέρη. Στο πρώοτ μέρος χρησιμοποιούνται μικϱά συνθετικά προγράμματα ενώ στο δεύτερο χρησιμοποιείται
πραγματικό λογισμικό. Τα συνθετικά τεστ μπορούν να βρεθούν στο παράρτημα. 

\section{Synthetic Tests}
Τα συνθετικά τεστ έχουν προέλθει από διάφρορες πηγές και δεν είναι ιδιαίτερε πολύπλοκα καθώς θέλουμε απλώς να μας δείξουν τις
διαφορές στην επίδοση μεταξύ Source-DPOR και Nidhugg-DPOR.

\begin{itemize}
\item writer-N-readers: Σε αυτό το τεστ N threads διαβάζουν (readers) την ίδια global μεταβλητή και ένα thread (writer)
γράφει σε αυτή τη μεταβλητή. Είναι σηματνικό να σημειώσουμε ότι πριν την ανάγνωση της μεταβλητής κάποιο local operation του thread λαμβάνει
χώρα. Επομένως αναμένουμε σημαντική διαφορά στην επίδοση μεταξύ των source sets και persistent sets.

\item Account: Αυτό το τεστ αποτελεί μια προσομοίωση ενός τραπεζικού λογαρισαμού και χρησιμοποιεί locks για κάθε operation που συμβαίνει
    στον λογαριασμό. Υπάρχουν τρείς δυνατές λειτουργίες: Να αυξήσουμε το απόθεμα του λογαριασμού κατά ένα ποσό. Να κάνουμε ανάληψη μειώνοντας
    το απόθεμα με ένα συγκεριμένο ποσό. Να ελέγξουμε το αποτέλεσμα check\_result (έλεγχος αποτελέσματος) όπου επιβεβαιώνουμε ότι $\text{final\_balance} ==
\text{initial\_balance} + \text{deposit} - \text{withdraw}$ και μπορεί να συμβεί μόνο αν η κατάθεση και η ανάληψη έχουν ολοκληρωθεί.

\item Micro: Σε αυτό το τεστ τρία threads δημιουργούνται και εκτελούν δύο φορές την εντολή \verb|x++| δύο φορές. Η συγκεκριμένη εντολή \verb|x++|
αποτελείται από δύο επιμέρους λειτουργίες μία ανάγωσης της τιμής της μεταβλητής και μία το γράψιμο της μεταβλήτης.

\item Last-zero test: Το πρόγραμμα αποτελείται από N+1 threads τα οποία εκτελούν λειτουργίες σε N+1 στοιχεία ενός πίνακα που αρχικά όλα είναι μηδενικά.
Σε αυτό το πρόγραμμα το thread 0 αναζητά το μηδενικό στοιχείο του πίνακα με το μεγαλύτερο index ενώ τα άλλα N threads
διαβάζουνε από τον πίνακα ένα στοιχείο και ενημερώνουν την τιμή του επόμενου. Η τελική κατάσταση του προγράμματος ορίζεται μοναδικά από τις που θα 
έχει ο πίνακα. Το Last-zero δεν παράγει περισσότερα tracce από τον DPOR για λόγους που εξηγούνται στη συνέχεια. Μια παραλλαγή του ενδιάμεσου
κώδικα μπορεί να δείξει τη διαφορά.

\item Indexer.c: Αυτό το benchmark χρησιμοποιεί την compare-and-swap(CAS) primitive instruction για να ελέγξει να ένα entry στον
    πίνακα είναι 0 και στη συνέχεια θέτει μια καινούρια τιμή σε αυτό.

\item Indexermod.c: Σε αυτό το benchmark όλα τα threads διασχίζουν και προσπαθούν να γράψουν έναν πίνακα με αποτέλεσμα να προκύπτουν
    πολλές συγκρούσεις μεταξύ των threads.

\end{itemize}

\section{RCU}

To Read-Copy-Update (RCU) είναι ένα μηχανισμός συγχρονισμού που εφευρέθηκε από τους McKenney and Slingwine \cite{McKenney98},
και βασίζεται στην αμοιβαία απόκληση πόρων. Προστέθηκε τον πυρήνα του Linux τον Οκτώβριο του 2002 και επέτρεψε σημαντίκη 
βελτίωση στην ταυτόχρονη ανάγνωση και ενημέρωση. Σε αντίθεση με τα συνήθη locking primitives που διασφαλίζουν αμοιβαίο αποκλεισμό
μεταξύ threads ανεξάρτητα με το αν είναι αναγνώστες ή εγγραφείς ή με τη χρήση reader-writer locks που επιτρέπουν ταυτόχρονες
αναγνώσεις ή μία εγγραφή, το RCU επιτρέπει ταυτόχρονες αναγνώσεις και μία εγγραφή.

Η τεχνική του DPOR χρησιμοποιήθηκε σαν μια προσέγγιση για ελεγχθεί συστηματικά ο κώδικα του RCU που χρησιμποιείται στο Linux kernel (Tree
RCU) κάτω από το memory model του sequential consistency. Η μοντελοποίηση επιτρέπει στο Nidhugg
να αναπαράγει σε μερικά δευτερόλεπτα σφάλαμτα που έχουν αναφερθεί κατα καιρούς σχετικά με το RCU \cite{Spin}.

Το RCU είναι ένα ιδανικό testcase για την αξιολόγησης διαφόρων υλοποιήσεων του DPOR και Bounded DPOR καθώς:
\begin{itemize}
\item Είναι ένα πρόγραμμα που χρησιμοποιείται πραγματικά και όχι ένα συνθετικό τεστ synthetic test.
\item Ο αριθμός των διαφορετικών δρομολογήσεων είναι αρκετά μεγάλος για να δούμε διαφορές στην επίδοση.
\item Προηγούμενη δουλειά  \cite{Spin} μας επιτρέπει να αξιολογήσουμε την ορθότητα των υλοποιήσεων μας.
\end{itemize}


\section{Αξιολόγηση των Μη Φραγμένων Αλγορίθμων}
Όπως έγινε σαφές στο κεφάλαιο \ref{unbounded} η υλοποίηση των persistent sets είναι πολύ σημαντική καθώς χρησιμοποιείται
σε κάθε bounding technique. Σε αυτή την ενότητα θα δείξουμε τις διαφοϱες στην επίδοση μεταξύ των Source-DPOR και
Nidhugg-DPOR τόσο στα συνθετικά tests όσο και στο RCU.

\subsection{Αξιολόγηση των Persistent Sets στα Συνθετικά Τεστ}
Τα αποτελέσματα παρουσιάζονται με δύο διαφορετικούς τρόπους. Τα αποτελέσματα για το writer-N-readers testcase δίνονται σε μορφή γραφήματος, 
στο Figure \ref{writer-N-readers}, προκειμένου να απεικονίσουμε την κλιμάκωση του χώρου καταστάσεων καθώς
και την σημαντική επίδραση που έχει ο source-DPOR. Τα υπόλοιπα αποτελέσματα δίνονται στο Table \ref{Source-DPOR vs Nidhugg-DPOR for synthetic tests} 
ώστε να μπορέσουμε εύκολα να τα συγκρίνουμε. Ηθελημένα δεν σημειώνουμε τη διάρκεια εκτέλεση καθώς στις περισσότερες περιπτώσεις ο αριθμός
των traces είναι πολύ μικρός όπως και ο χρόνος.
Όπως ήταν αναμενόνμενο τα συνθετικά testcase έδειξαν ότι ο Source-DPOR πράγματι έχει καλύτερη επίδοση από τον
Nidhugg-DPOR. Όπως ήταν αναμενόμενο ο Source-DPOR εξερευνά λιγότερα traces από τον Nidhugg-DPOR. Είναι σημαντικό να
σημειώσουμ ότι η διαφορά οφείλεται στον αριθμός των sleep set blocked traces τα οποία προκύτπουν από τον DPOR αλγόριθμο 
και τα οποία δεν συναντάμε στον source DPOR. Αυτή η μείωση δεν είναι σταθερή σε όλες τις περιπτώσεις.

\graph{img/wNr.png}{writer-N-readers}

\smalltabular{"tables/synthetic_unbounded.tex"}{Source-DPOR vs Nidhugg-DPOR for synthetic tests}

\subsection{Evaluation of Persistent sets on RCU}
Παρατηρήσμα ότι δεν υπάρχει διαφορά μεταξύ Source sets και persistent sets και επομένως δεν παρουσιάζουμε αποτέλεσματα
καθώς αυτά θα συμφωνούν με αυτα του \cite{Spin}. Ο λόγος που τα αποτελέσατα του Nidhugg-DPOR και Source-DPOR είναι ίδια οφείτεαι 
στις λειτουργίες που εκτελούνται και που δεν επιτρέπουν την βελτιστοποίηση του Source-DPOR.

\section{Σύγκριση με τα αποτελέσματα του Concuerror}
Ο Concuerror είναι ένα εργαλείο που αναπτύχθηκε από την ίδια ερευνητική ομάδα και έχει στόχο να εντοπίζει σφάλματα
σε προγράμματα Erlang. Επομένως η σύγκριση της επίδοσής του μπορεί να μας δώσει μια ένδειξη για την ορθότητα των
υλοποιήσεών μας.
Υπάρχουν περιπτώσεις here Concuerror's Source-DPOR εξερευνά λιγότερα traces από τον Classic-DPOR ενώ στο Nidhugg αυτό δεν ισχύει.
Επιπλέον, η υλοποίηση του Nidhugg-DPOR φαίνεται να εξερευνά λιγότερα traces από αυτά που εξερευνόνται από τον
Classic-DPOR του Concuerror \cite{AbdullaAronisJohnssonSagonasDPOR2014}. Προσπαθήσαμε να ερμηνεύσουμε αυτή τη συμπεριφορά και συμπεράναμε
ότι οι λόγοι που οι τιμές διαφέρουν είναι οι εξής:

\begin{itemize}
  \item Η υλοποίηση των persistent set: Στον Concuerror ο υπολογισμός των persistent sets είναι πιο χαλαρός από του
  Nidhugg με αποτέλεσμα το τελευταίο να υπολογίζει μικρότερα persistent sets. Στο Figure \ref{Lastzero Concuerror} 
  δίνεται το παράδειγμα του Last-zero testcase του Concuerror ως παράδειγμα υπολογισμού μεγαλύτερου persistent set. Στην πραγματικότητα
  το $q$ δε θα έπρεπε ποτέ να προστεθεί στο persistent set καθώς δεν έχει conflict με άλλες διεργασίες.

  \item Ο αριθμός των traces που εξερευνότναι σχετίζεται άμεσα με την δρομολόγηση των γεγονότων: Έστω ένα πρόγραμμα που αποτελείται από
      δύο διεργασίες που διαβάζουν μια μεταβλητή $x$ και μία που γράφει σε αυτή τη μεταβλητή $x$. Στο Figure \ref{Scheduling Effect
  reader-writer-reader} παρουσιάζεται η εξερεύνηση όταν ο ένας αναγνώστης δρομολογείται πρώτος. Παρατηρούμε ότι εξερευνόνται ακριβώς
  4 traces. Στην περίπτωση που δρομολογούντας πρώτα ο εγγραφέας \ref{Scheduling Effect
  writer-reader-reader} θα εξερευνότναν 5 traces με το ένα trace να γίνεται sleep set blocked.

\end{itemize}

\tracelong{lastzero.pdf}{Lastzero Concuerror}

\trace{schedulingrwr.pdf}{Scheduling Effect reader-writer-reader}
\trace{schedulingwrr.pdf}{Scheduling Effect writer-reader-reader}


\section{Evaluation of Bounding Techniques}
The evaluation of the bounding techniques takes into account two aspects. The number of traces explored and the
soundness. The former is closely related with the amount of time required for a bug to be found or the whole state space
to be explored. The second is important because it demonstrates the tradeoff between time and accuracy of the results
discussed in chapter \ref{bounded}. It is intelligible that a faster algorithm may compromise the soundness of the state
space.

\subsection{Evaluation of Bounding Techniques on Synthetic tests}

The results for the testcases are demonstrated in this section. Again they are presented in two different ways.

\graph{img/wNrB.png}{writer-N-readers bounded}
\smalltabular{"tables/bounded.tex"}{Traces for various bound limits}

As it was expected the Naive-BPOR explores significantly less traces than the Nidhugg-BPOR and the Source-DPOR. However,
as it was previously discussed, the whole state space is not explored. The number of traces explored by the sound
algorithms is significantly greater and it caused by the many conservative branches that are added in order to achieve
soundness. Surprisingly, there is no difference between the other two bounding techniques. An explanation is given
later.

\subsection{Evaluation of Bounding Techniques on RCU}
The results of the various implementetions of BPOR are given here. Notice that since the Source-DPOR did not resulted
less traces than the DPOR we could not expect from the Source-BPOR and Nidhugg-BPOR to differentiate. Moreover tests did not
reveal any difference. For these reasons only the performance of Naive-BPOR and Nidhugg-BPOR is examined. In each table the
results with a given bound are demonstrated. Specifically the exploration time and the number of traces are shown.
Moreover there is a cell indicating whether the assertion was found (We note F for found and NF for not found).


\bigtabular{"tables/nobound.tex"}{RCU results without bound}
\bigtabular{"tables/naivevsbpor0.tex"}{RCU results for bound $b=0$}
\bigtabular{"tables/naivevsbpor1.tex"}{RCU results for bound $b=1$}
\bigtabular{"tables/naivevsbpor2.tex"}{RCU results for bound $b=2$}
\bigtabular{"tables/naivevsbpor3.tex"}{RCU results for bound $b=3$}
\bigtabular{"tables/naivevsbpor4.tex"}{RCU results for bound $b=4$}
\bigtabular{"tables/dporvsbpor.tex"}{Comparison between DPOR and BPOR}


We notice that some assertions are found significantly faster. The most spectacular result is the
\verb|-DFORCE_FAILURE_3| which is found in only 6 seconds for bound $b=3$ whereas it requires 464.77 seconds in the
unbounded version. Moreover we notice for bound $b=4$ all the errors that are found in the unbounded version are found. As
a result the empirical observation that errors occur in low bound count seems to be confirmed. However, we have to
underline that these are contrived errors aiming to verify the correctness of the rcu and as a result they cannot be
regarded as substantial evidences. As it is expected for larger bounds ($b=4$) the number of traces grows exponentially.
An other impressive result is that when the bound grows larger the errors takes longer to be found. If we take a look at
\verb|-DFORCE_FAILURE_3| again we notice that the error takes significantly longer to be tracked even through it exposed
for the first time at bound $b=2$. For $b=4$ the exploration will was stopped since it exceeded 100,000 traces. On the other
hand many assertions are found faster with source-DPOR.

\subsection{A known bug}
As it was discussed in previous section, the scheduling priorities of Nidhugg should be changed in order for the running
thread to be prioritize since it does not increase the bound count. However this alternation in the priority causes
Nidhugg to explore many more traces in unbounded search for an unknown reason. In order to deal with this problem
alternation in priority occurs only when bound is applied. As a result the comparison between DPOR and BPOR is biased.
Looking at table \ref{Comparison between DPOR and BPOR with the bug} we can clearly see that the minimum traces required
for BPOR to track the bug for the first time are always less than DPOR

\bigtabular{"tables/dporvsbporpriority.tex"}{Comparison between DPOR and BPOR with the bug}

\section{Equivalence between Classic-BPOR and Source-BPOR (Correctness of Source-BPOR)}
Surprisingly the results of Classic-BPOR and Source-BPOR always coincide. However, further investigation of this
behavior can reveal that these two techniques are actually equivalent. 

It can be proved that a branch which was rejected by the Source-DPOR but accepted by the Classic-BPOR algorithm as a
non-conservative one will be added as conservative by the source-bpor algorithm.

Let us assume a branch of the thread $b$ that is added as a non-conservative by the BPOR algorithm. Let $T$ be the
persistent set at that point.

By the definition of persistent-sets this means that there is a $t \in T$ which
conflicts with an execution step of $b$. 

This non-conservative branch is rejected by the Source-BPOR. We know that there must be a trace such that thread $b$
 occurs before $t$. Since $b$ was rejected there must be another branch $s$ which shares the same initials with $b$, 
  
When $s$ is scheduled another block will be created.
 
\begin{itemize}

\item Case 1: $s$ has an execution step which conflicts with $b$. Hence, there must be a trace where $b$ happens before
some step of $s$ and $s$ happens before $t$. Since $b$ happens-before some execution step of $s$ but share the same
initials with $s$, $b$ must be added as a conservative branch at the point where it was rejected at the initially. As
shown in the Figure \ref{Source-BPOR and Nidhugg-BPOR equivalence Case 1}, the branch which seems to be initially
rejected, will finally be added by the Source-BPOR and as a result belongs to the source-set. 
\trace{equivalence_case1w.pdf}{Source-BPOR and Nidhugg-BPOR equivalence Case 1}
   
\item Case 2: $s$ doesn’t conflict with $b$ (both $b$ and $s$ are read operations). There must $b$ a trace s.b.t (where
   s,b,t is the execution of all the steps of s,b,t). Since $t$ conflicts with an execution step of $s$ the first step
   of $b$ is an initial for $t$ and it will be added both as non-conservative branch and as conservative at the
   beginning of the block where it was rejected by the Source-DPOR. For Figure \ref{Source-BPOR and Nidhugg-BPOR
   equivalence Case 2}, both $s$ and $b$ belong to the persistent set. However, the $b$ thread will be rejected since it
   shares the same initials with the $s$ thread. However it will be added as a conservative set. Notice that it would be
   added as a non-conservative as well but we have already shown that when both conservative and non-conservative
   branches of the same thread are added we must keep the conservative one.

   \trace{equivalence_case2.pdf}{Source-BPOR and Nidhugg-BPOR equivalence Case 2}

\end{itemize}
   
A more intuitive explanation of the equivalence of the two techniques would be based on the following two observation:
\begin{itemize}
  \item Let $B_v$ be a function that calculates the bound count then $B_v(pre(E,e)) \leq B_v(E)$ for every $e \in E$.
  \item The points in the trace where the bound count increases are those where branches are added.
\end{itemize}

As a result a Classic-BPOR algorithm would have to add conservative branches at points where the bound increases. The
non-conservative branches that would have been rejected by the Source-DPOR are added as conservative ones to since the
lead to already explored traces but with a smaller bound count.

We have proved that Source-BPOR is sound since the traces explored by the Classic-BPOR are subset of the traces explored
by the Source-BPOR.
