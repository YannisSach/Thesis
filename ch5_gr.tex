\chapter{Επιπλέον Συζήτηση του Bounding Problem}
\label{Chapter 5}

Σε αυτό το κεφάλαιο συζητόνται εναλλακτικές προσεγγίσεις του preemption bounding problem για τον DPOR.
Προτείνεται μια καινούρια προσέγγιση η οποία δείχνουμε ότι είναι ισοδύναμη με την προσθήκη συντηρητικών διακλαδώσεων η οποία όμως δεν χρησιμοποιεί 
συντηρητικές διακλαδώσεις.

\section{Τεχνικές χωρίς την Προσθήκη Συντηρητικών Διακλαδώσεων}

Σε προηγούμενο κεφάλαιο συζητήσαμε τις προκλήσεις που προκύπτουν από τη σχεδίαση ενός Bounded DPOR αλγορίθμου. Είδαμε ότι δεν μπορούν να γίνουν
σημαντικές βελτιώσεις όταν προσθέτουμε συντηρητικές διακλαδώσεις και ότι πολλές βελτιστοποιήσεις που δουλεύουν για τις μη φραγμένες εκδοχές των
αλγορίθμων δεν δουλεύουν για τις φραγμένες εκδοχές τους.

\subsection{Κίνητρο}
Ο μόνος αλγόριθμος που δεν προσθέτει συντηρητικές διακλαδώσεις είναι ο Naive-BPOR. Για ένα επαρκές bound ένα trace που περιείχε 
σφάλμα θα εξετάζοταν από τον αλγόριθμο. Το ελλάτωμα αυτού του αλγορίθμου είναι ότι δεν είναι sound.
Σε αυτό τον αλγόριθμο μια συνάρτηση υπολογίζει τον αριμό των preemptive switches. Όμως πολλές switches που υπολογίζονται μπορούν να 
αποφευχθούν.

Ένα παράδειγμα δίνεται στο Figure \ref{An example of avoidable preemption-switch} που εξηγεί καλύτερα την ιδέα. Έστω 
ένα πρόγραμμα που αποτελείτα από τις διεργασίες $p$ και $q$. Η διεργασία $p$ γράφει μια μοιραζόμενη μεταβλητή $x$ και η διεργασία $q$ διαβάζει
μια μεταβλητή $y$ (η οποία δεν τροποιείται από κάποια άλλη διεργαία), και γράφει την μεταβλητή $x$. Υπάρχουν δύο δυνατά 
interleavings όπως φαίνεται και στην εικόνα. Αν υποθέσουμε ότι κάνουμε εξερεύνηση με bound $0$ τότε και μια συντηρητική διακλάδωσηη πρέπει να 
προστεθεί.

\trace{motivation.pdf}{An example of avoidable preemption-switch}

Στο Figure \ref{An example of avoidable preemption-switch} το preemptive switch που λαμβάνει χώρα θα μπορούσε εύκολα να αποφευχθεί αντιστρέφοντας
απλώς την πρώτη εντολή του $q$ με την πρώτη την $p$. Αλλά τί επιτρέπει αυτή την αλλαγή;

Η απάντηση βρίσκεται στα γεγονότα που αποτελείται το block. Στην περίπτωσή μας το block αποτελείται από 
ένα μόνο βήμα. Το πρώτο block διαβάζει μια μεταβλητή που δε χρησιμοποιείτα από άλλο block. Επομένως τα δύο block δεν έχουν happens-before
σχέση.

Η παρατήρηση αυτή οδηγεί στο επόμεον ερώτημα: Ποία preemption switches είναι υποχρεωτικά; Ή ισοδύναμα ποια traces δεν μπορούν να παραχθούν
χωρίς preemptive switch; Επιπλέον, είναι δυνατό για ένα trace να υπολογίσουμε τον ελάχιστο αριθμό από preemptive switches που θα απαιτούσε ένα
ισοδύναμο trace;

\subsection{Ένας Αλγόριθμος χωρίς Συντηρητκές Διακλαδώσεις}
Ένας αλγόριθμος που θα έκανε bounded search θα ήταν διαφορετικός από τον Naive-BPOR μόνο σε ότι αφορά τη συνάρτηση που υπολογίζει το
preemption count της δρομολόγησης. Αυτή η συνάρτηση $f$ θα ήταν αύξουσα δηλαδή θα ίσχυε για ένα πρόθεμα $E$, $f(E) \leq f(E.E')$ για κάθε $E'$.

Η γενική μορφή του αλγορίθμου δίνεται στον Αλγόριθμο \ref{NBBPOR}.

\begin{algorithm}[H]
    \SetAlgoLined
    \caption{General form of the BPOR without branch addition}
    \label{NBBPOR}
    \KwResult{Explore the whole state space within the bound}
    Explore($\emptyset$)\;
    \Fn{Explore($S$)}{
        T = Sufficient\_set($final(S)$)
     \For{all $t \in T$}{
         \If{$min\{B_v([S.t])\} \leq c$}{
            Explore($S.t$)
         }
        }
    }
\end{algorithm}

Συγκρίνοντας τον Αλγόρθμο \ref{NBBPOR} με τον \ref{GeneralDPOR} παρατηρούε ότι αντί να υπολογίζουμε το $B_v(S.t)$ δηλαδή το preemption
count ενός trace υπολογίζουμε το $min(B_v[S.t])$ δηλαδή το ελάχιστο $B_v$ για όλα τα ισοδύναμα traces.

\subsection{Υπολογισμός του Ελάχιστου Preemption Count}
To μόνο που μας μένει είναι η κατασκεύ της συνάρτησης $f$. Για ένα trace $E$ που αποτελείται από blocks πολλές σχέσεις 
happens-before ισχύουν. Κάθε ισοδύναμο trace πρέπει να συμφωνεί με αυτές τις σχέσεις. Επίσης σχέσεις happens-before ισχύουν
για τις εντολές εντός ενός block. Γι αυτή την ενότητα μόνο θα μας απασχολήσουν οι σχέσεις μεταξύ blocks.
Οι λόγοι που έγινε αυτή η επιλογή είναι οι εξής:

\begin{itemize}
    \item Οι αλγόριθμοι που παρουσιάζονται στη συνέχεια είναι πολύ πιο απλοί.
    \item Δεν μας ενδιαφέρει να σπάσουμε περαιτέρω κάθε block και επομένως μπορούμε να δούμε τοblock σαν μια ενότητα.
\end{itemize}

Αυτές οι σχέσεις happens-before σχηματίζουνε ένα γράφο. Αυτός ο γράφος αποτελείται από κόμβους που αντιστοιχούν σε blocks και 
ακμές που αντιστοιχούν στις σχέσεις μεταξύ τους. Προφανώς block που ανήκουν στο ίδιο thread έχουν happens-before σχέση.
Επίσης μπορούμε να κινηθούμε από το ένα block στο άλλο από τη στιγμή που αυτά είναι ταυτόχρονα.
Προσθέτουμε βάρη σε κάθε ακμή. Ακμές που συνδέουν blocks του ίδιου thread έχουν βάρος $0$. Οι ακμές που ξεκινάν από block
που είναι μπλοκαρισμένα έχουν επίσης βάρος $0$. Οι υπόλοιπες ακμές έχουν βάρος ένα.

Προκειμένου να βρούμε το ελάχιστο preemption count διασχίζουμε όλα τα block του γράφου χωρίς να παραβιάζουμε τις happens-before σχέσεις.
Επομένως το minimum bound count αντιστοιχεί στο ελάχιστο hamiltonian μονοπάτι το οποίο δεν παραβίαζει τις happens-before σχέσεις.

Επειδή ο υπολογισμός του ελάχιστου hamiltonian μονοπατιού είναι απαιτητικός κατασκευάζουμε ένα γράφο που περιορίζει όσο αυτό είναι
δυνατό πιθανές διασχίσεις που παραβιάζουν τις σχέσεις happens-before.

\noindent Ένας αλγόριθμος που προσθέτει τα blocks στο γράφο είναι δίνεται στον Αλγόριθμο \ref{Adding a new block to the
dependencies graph}. Ο αλγόριθμος λειτουργεί επαγωγικά. Αρχικά ο γράφος αποτελείται από το πρώτο block. Όταν block
του trace ολοκληρώνεται το προσθέτουμε στο γράφο. Προσθέτουμε κάθε block που συμβαίνει ταυτόχρονα με ένα άλλο block με διπλή ακμή
Επιπλέον συνδέουμ το πιο πρόσφατο block κάθε thread που συμβαίνει πριν από το καινούριο block με ακμες που καταλήγουν στο καινούριο block.

\SetKw{Return}{return \;}
\SetKw{Break}{break \;}
\begin{algorithm}[H]
    \caption{Adding a new block to the dependencies' graph}
    \label{Adding a new block to the dependencies graph}
    \Fn{AddBlock(block,graph)}{
        \If{previous block of the same thread was not blocked}{
            increase the weigh of the edges coming from the previous block to 1 \;
        }

        \For{each thread t}{
            list:= preceding blocks t\;
            \For{l in reversed(list)}{
                \If{$l \leftrightarrow block$}{
                    add edge from $block$ to $l$ with weight $0$ \;
                    \If{$l$ is not last}{
                        add edge from $l$ to $block$ with weight $1$ \;
                    }
                    \Else{
                        add edge from $l$ to $block$ with weight $0$ \; 
                    }
                }
                \If{$l \rightarrow block$}{
                    \If{$l$ is not last}{
                        add edge from $l$ to $block$ with weight $1$ \;
                    }
                    \Else{
                        add edge from $l$ to block with weight $0$ \; 
                    }
                    \Break
                }
            }
        }
    }
\end{algorithm}


\trace{compulsoryswitch.pdf}{Graph example}

In Figure \ref{Graph example} a simple example of such a graph is demonstrated. For this trace we notice that $w(y)$ of
$q$ thread is concurrent with $r(x)$ while it happens before $w(y)$ of the $p$ thread. Each transition costs 1
preemption switch that is why the weight is 1. Moreover transitions between the same thread cost 0. The most important
fact, however, is that if for any reason we try to violate the happen before relation (e.g. starting from $r(x)$ we jump
to $w(x)$) there is no way to traverse all the nodes. 

We can see that there is a hamiltonian path with weight 1 for the given trace. In fact, this is the minimum hamiltonian
path of the graph. We can easily realize that there is no equivalent trace with the initial one that has bound count
less than 1. 

We can infer that the calculation of this bound count is reduced to the weight of the minimum hamiltonian path of this
graph. This problem it is known to be NP-complete. As a result any algorithm that would calculate this weight would not
be significantly better than a DFS-exploration. 

This is an extremely interesting indication of the difficulty of the DPOR bounding problem since the addition of the
conservative sets imply this DFS exploration at the state space. As a result this algorithm would not be better than the
already proposed BPOR algorithm.

Now that the difficulty of this approach is clear a new question arises. Is it possible to approximate the total weight of the minimum hamiltonian path?
Such an algorithm would cover a greater state space than the Naive-BPOR without the explosion caused by the conservative branches.

\subsection{Approximating Bound Count}
There are two approaches examined in order to approximate the value of the bound count. The idea of both algorithms is
based on this observation: A preemption switch is compulsory when for two blocks of the same process A a block of
another process B must intervene in order for the happens-before relations to hold true. As a result, the execution of
the first A block should stop so the execution of the B block takes place followed by the execution of the A block
again. Hence it should hold $e_1(A) \rightarrow e(B) \rightarrow e_2(A)$. In case of $e_1(A) \not \rightarrow e(B)$ or
$e(B) \not \rightarrow e_2(A)$ we could invert the blocks without affecting the happens-before relations and, thus
construct an equivalent trace with lower bound count.

The algorithm is presented here:\\

\SetKwProg{Fn}{Function}{}{}
\begin{algorithm}[H]
    \caption{First Approximation Algorithm}
    \label{First Approximation Algorithm}
    \Fn{BoundCount($E$,$current\_bound$)}{
        \For{$i=0 \text{ to } len(E)-1$}{
            \If{$E[i].pid = last(E).pid$}{
                $higher\_block = i$ \;
                \Break
            }
        }
        \For{$i = higher\_block+1 \text{ to } len(E)-1$}{
            \If{$ E[higher\_block] \rightarrow E[i] \rightarrow last(E)$}{
                current\_bound++ \;
                \Return
            }
        }
    }
\end{algorithm}

In Algorithm \ref{First Approximation Algorithm} we find the most recent block with the same pid as with the last block. We, then try to find if there is an event that happens before the first
and after the last event. If exists such an event we increase the counter.
Notice that for establishing the happens-before relation vector clocks can be used.
Moreover, it is obvious that more happens-before relations can be counted.


Th second algorithm explores more state space than it is required.\\

\begin{algorithm}[H]
    \caption{Second Approximation Algorithm}
    \Fn{BoundCount($E$,$current\_bound$)}{
        \For{$i=len(E)-1 \text{ to } 0$}{
            \If{$E[i].pid = last(E).pid$}{
                $lower\_block = i$ \;
                \Break
            }
        }

        \For{$i = lower\_block+1 \text{ to } len(E)-1$}{
            \If{$ E[lower\_block] \rightarrow E[i] \rightarrow last(E)$}{
                current\_bound++\;
                \Return
            }
        }
    }
\end{algorithm}

This algorithm starts the search for an event that intervenes the two events of the same id from the immediately previous block 
with the same id. 

\subsection{Evaluation of Approximating Algorithms}
The previous discussed approaches were tested and produced some interesting results. The both estimation algorithms seem
to be ``more sound'' than the BPOR and may explore traces that exceed the bound. This stems from the fact that they tend
to underestimate the bound count since there are more complex relations between blocks that result traces with higher
bound count than the one estimated. We notice that in writer-N-readers example the number of traces explored is stable
for every bound. In fact, each trace of this test has an equivalent trace with zero bound count since in each thread
only a command related to a shared variable is executed.

\graph{img/wNrLB.png}{writer-N-readers bounded by the first estimation algorithm}
\smalltabular{tables/lazy1_bounded.tex}{Traces for the first estimation algorithm for various bound limits}

\subsection{Implementation of Lazy-BPOR}

Some of the testcases such as lastzero or writer-N-readers made clear that an implementation of a bound count function
which does not simply counts the preemptive switches in traces can prevent the state space explosion caused by the
conservative branches added. The next step is to implement the Lazy-BPOR, an algorithm that calculates the number of
compulsory preemptive switches (preemptive switches that cannot be avoided in any equivalent trace with the one
examined). The main difference from the Naive-BPOR is that the Lazy-BPOR maintains throughout the execution of the DPOR
a graph of the blocks that are contained in the traces. When a new block is created, it is added by the algorithm
previously described. When it comes to the calculation of the bound count, the minimum hamiltonian path is calculated.
The weight of this path corresponds to the bound count taken into consideration.

\begin{algorithm}
    \caption{Lazy-BPOR}
    \label{Lazy-BPOR}
    \Let{$G =: \emptyset$}
    Explore($\langle \rangle$,$\emptyset$,$G$,$b$)\;
    \Fn{Explore($E$,$Sleep$,$G$,$b$)}{
        \If{$\exists p \in (enabled(s_{[E]}) \backslash Sleep)$ such that $B_v(E.p) \leq b$ }{
            backtrack(E) $:={p}$ \;
            \While{$\exists p \in (backtrack(E) \backslash Sleep $}{
                \ForEach{$e \in dom(E)$ such that $e \lesssim_{E.p} next_{[E]}(p) $}{
                    \Let{$E' = pre(E,e)$}
                    \Let{$u = notdep(e,E).p$}
                    \If{$I_{E'}(u) \cap backtrack(E') = \emptyset$}{
                        add some $q' \in I_{[E']}(u) to backtrack(E') $ \;
                    }
                }
                \Let{$Sleep' := \{q \in Sleep \mid E \models p \diamondsuit q \} $}
                \If{$p$ creates a new block}{
                    \Let{$block$ = $last\_block(E)$}
                    \Let{$G'$ = add\_block($block$,$G$)}
                }
                \If{$min \{ Ham\_path(G') \text{ which compensate with all happens-before relations of } E \} \leq b $}{
                    $Explore(E.p, Sleep,G',b)$ \;
                    add $p$ to $Sleep$ \;
                }
            }
        }
    }
\end{algorithm}



\subsection{Lazy-BPOR - RCU Evaluation}

The results are demonstrated below. Since we have to compare Lazy-BPOR with BPOR the bugged versions of the DPOR must be used. The bugged version
of DPOR is that where the last running thread is prioritized.

At Figures \ref{Comparison between DPOR and Lazy-BPOR} and \ref{Comparison between BPOR and Lazy-BPOR} we present the results for the various
testcases of RCU test suite.


\landscapetabular{"tables/lazy_comp.tex"}{Comparison between DPOR and Lazy-BPOR}

\landscapetabular{"tables/lazy_buged_comp.tex"}{Comparison between DPOR and Lazy-BPOR without the bug}


We compare the algorithm with BPOR. We notice that Lazy-BPOR examines less traces but requires longer time since the cost of the lazy bound count is significantly
increased. This is due to the calculation of the minimum hamiltonian path.

\landscapetabular{"tables/hline_pandas_lazy_preep.tex"}{Comparison between BPOR and Lazy-BPOR}

\section{Conclusion}
Even though the Lazy-BPOR is not proved to be a more efficient way than all the other sound BPOR algorithms examined in this thesis it
provides some interesting results.

\begin{itemize}
    \item It is possible to explore a preemption-bounded state space without the addition of conservative branches.
    \item It provides an upper bound for the number of traces explored in BPOR no matter the bound. In fact the number of traces
    explored by Lazy-BPOR at worst case equal to the number of traces explored by the unbounded DPOR. This is true since no conservative
    branches are added.
    \item The most important is that provides a reduction of the preemption-bounded search to a well known graph problem where many heuristics can
    be applied in order to expedite the calculation of the minimum hamiltonian path.
\end{itemize}

