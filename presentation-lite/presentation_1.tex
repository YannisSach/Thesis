%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Beamer Presentation
% LaTeX Template
% Version 1.0 (10/11/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND THEMES
%----------------------------------------------------------------------------------------

\documentclass[9pt]{beamer}

\mode<presentation> {

% The Beamer class comes with a number of default slide themes
% which change the colors and layouts of slides. Below this is a list
% of all the themes, uncomment each in turn to see what they look like.

%\usetheme{default}
%\usetheme{AnnArbor}
%\usetheme{Antibes}
%\usetheme{Bergen}
%\usetheme{Berkeley}
%\usetheme{Berlin}
%\usetheme{Boadilla}
%\usetheme{CambridgeUS}
%\usetheme{Copenhagen}
%\usetheme{Darmstadt}
%\usetheme{Dresden}
%\usetheme{Frankfurt}
%\usetheme{Goettingen}
%\usetheme{Hannover}
%\usetheme{Ilmenau}
%\usetheme{JuanLesPins}
%\usetheme{Luebeck}
%\usetheme{Madrid}
%\usetheme{Malmoe}
%\usetheme{Marburg}
%\usetheme{Montpellier}
%\usetheme{PaloAlto}
%\usetheme{Pittsburgh}
%\usetheme{Rochester}
\usetheme{Singapore}
%\usetheme{Szeged}
%\usetheme{Warsaw}

% As well as themes, the Beamer class has a number of color themes
% for any slide theme. Uncomment each of these in turn to see how it
% changes the colors of your current slide theme.

%\usecolortheme{albatross}
%\usecolortheme{beaver}
%\usecolortheme{beetle}
%\usecolortheme{crane}
%\usecolortheme{dolphin}
%\usecolortheme{dove}
%\usecolortheme{fly}
%\usecolortheme{lily}
%\usecolortheme{orchid}
%\usecolortheme{rose}
%\usecolortheme{seagull}
%\usecolortheme{seahorse}
%\usecolortheme{whale}
%\usecolortheme{wolverine}

%\setbeamertemplate{footline} % To remove the footer line in all slides uncomment this line
%\setbeamertemplate{footline}[page number] % To replace the footer line in all slides with a simple slide count uncomment this line

%\setbeamertemplate{navigation symbols}{} % To remove the navigation symbols from the bottom of all slides uncomment this line
}

\usepackage{graphicx} % Allows including images
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables
\usepackage[cm-default]{fontspec}
\usepackage{unicode-math}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fancyvrb}
\usepackage{float}
\usepackage{color}
%\usepackage[table,xcdraw]{xcolor}
\usepackage{siunitx}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage{pdflscape}
\usepackage{listings}
\usepackage{algorithm2e}


\usepackage{graphicx}



\usepackage{fontspec}
\usepackage{xunicode}
\usepackage{xltxtra}
%\setromanfont{Comic Sans MS}
\setromanfont{CMU Serif}
\setsansfont{CMU Sans Serif}
\setmonofont{FreeMono}
%\usepackage[english,greek{babel}
%\usepackage[iso-8859-7]{inputenc}
%\setmainfont{Minion Pro} % substitute with any font that exists on your system
%\setsansfont{Myriad Pro} % substitute with any font that exists on your system
%\setmonofont{Consolas} % substitute with any font that exists on your system
\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}



\setbeamertemplate{theorems}[numbered]

\newcommand{\img}[2]{
    \begin{center}
\includegraphics[scale=#1]{#2}
\end{center}
}


\graphicspath{ {img/} }
\newcommand{\trace}[2]{
\begin{figure}[H]
\centering
\includegraphics[scale=0.3]{#1}
\caption{#2}
\label{#2}
\end{figure}
}

\newcommand{\tracelong}[2]{
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{#1}
\caption{#2}
\label{#2}
\end{figure}
}

\newcommand{\graph}[2]{
\begin{figure}[H]
\centering
\includegraphics[scale=0.3]{#1}
\caption{#2}
\label{#2}
\end{figure}
}

\newcommand{\mediumGraph}[2]{
  \begin{figure}[H]
    \centering
    \includegraphics[scale=0.2]{#1}
    \caption{#2}
    \label{#2}
    \end{figure}
    }

\lstset{basicstyle=\ttfamily,columns=fullflexible}

\newcommand{\Code}[2]{
  \begin{minipage}{\linewidth}
  \lstinputlisting[basicstyle=\ttfamily\scriptsize,caption=#2,captionpos=b]{#1}
  \label{#2}
  \end{minipage}
 }

\newcommand{\Output}[2]{
  %%\BVerbatimInput[fontsize=\tiny]{#1}
  \begin{minipage}{0.85\textwidth}
  \lstinputlisting[label={#2},numbers=none,frame=none,caption=#2]{#1}
  \end{minipage}
  %%\caption{#2}
 }

\newcommand{\Side}[5]{
  %\begin{figure}
    \begin{minipage}{0.5\textwidth}
      \lstinputlisting[frame=none, numbers=none,caption={[#2]}]{#1}
    \end{minipage}
    %%\begin{minipage}{0.1\textwidth}
    %%  \includegraphics[scale=0.1]{arrow.pdf}
    %%\end{minipage}
    \begin{minipage}{0.5\textwidth}
      %%\VerbatimInput{#2}
      \lstinputlisting[frame=none, numbers=none,caption={[#4]}]{#3}
    \end{minipage}
    \captionof{figure}{#5}
    \label{#5}
    
     % \caption{#5}
     % \label{#5}
  %\end{figure}
} 

\newcommand{\bigtabular}[2]{
 \begin{table} 
   \resizebox{\linewidth}{!}{
      \input{#1}
    }
    \caption{#2}
    \label{#2}
 \end{table}
}

\newcommand{\landscapetabular}[2]{
\begin{landscape}
 \begin{table} 
   \resizebox{\linewidth}{!}{
      \input{#1}
    }
    \caption{#2}
    \label{#2}
 \end{table}
\end{landscape}
}

\newcommand{\smalltabular}[2]{
  \begin{table} 
    \resizebox{0.5\textwidth}{!}{\begin{minipage}{\textwidth}
     \input{#1}
     \caption{#2}
     \label{#2}
    \end{minipage}}
  \end{table} 
}

\newtheorem{thm}{Θεώρημα}[section]
\newtheorem{lem}[thm]{Λήμμα}
\newtheorem{por}[thm]{Πόρισμα}
\newtheorem{defn}[thm]{Ορισμός}
%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title[Short title]{Preemption Bounding Techniques for Dynamic Partial Order Reduction} % The short title appears at the bottom of every slide, the full title is only on the title page

\author{Σαχίνογλου Γιάννης} % Your name
\institute[NTUA] % Your institution as it will appear on the bottom of every slide, may be shorthand to save space
{
ΣΗΜΜΥ - ΕΜΠ \\ % Your institution for the title page
\medskip
\textit{03112089} % Your email address
}
\date{} % Date, can be changed to a custom date
\setcounter{subsection}{1}


\begin{document}

\begin{frame}
\titlepage % Print the title page as the first slide
\end{frame}

\begin{frame}
\frametitle{Summary} % Table of contents slide, comment this block out to remove it
\tableofcontents % Throughout your presentation, if you choose to use \section{} and \subsection{} commands, these will automatically be printed on this slide as an overview of your presentation
\end{frame}

%----------------------------------------------------------------------------------------
%	PRESENTATION SLIDES
%----------------------------------------------------------------------------------------

%------------------------------------------------
%------------------------------------------------

%\subsection{} % A subsection can be created just before a set of slides with a common theme to further break down your presentation into chunks

\begin{frame}
\frametitle{Aim of Thesis}
\begin{itemize}[<+->]
    \item Implement Preemption Bounded Search (BPOR) for Nidhugg. 
    \item Explore the potential of Source-Sets for BPOR.
    \item Evaluate the performance of various BPOR implementations.
    \item Explore alternative approaches to BPOR problem.
\end{itemize}

\end{frame}

\section{Background Knowledge}
%% \frame{\sectionpage}

\begin{frame}{Concurrent Computing and Problems}

Concurrent Computing: Concurrent computing is a form of computing in which several computations are executed during
overlapping time periods-concurrently-instead of sequentially (one completing before the next starts).\\

Potential problems include:
\pause
\begin{itemize}[<+->]
\item Race Conditions
\item Deadlocks
\item Livelocks
\item Resource Starvation
\end{itemize}

\end{frame}

\begin{frame}{Concurrency Errors}
\framesubtitle{ To be a Concurrency Error or not to be...}

\Code{../code/zero.c}{Example of non-concurrency error}

\Code{../code/zeroconc.c}{Example of concurrency error}

\end{frame}

\begin{frame}{Testing, Model Checking, and Verification}
\begin{itemize}
\item Testing: For some given inputs check whether the output is correct.
\item Verification: Prove formally that the output is correct.
\item Model Checking: Explore all the possible states the system can be.

\end{itemize}

\trace{../img/testmodver.png}{Comparing Testing, Model Checking and Verification}
    
\end{frame}

\begin{frame}{But What's Our State Space?}

\begin{itemize}[<+->]
    \item We need to model our state space!
    \item An Interleaving represents a scheduling of the concurrent program.
    \item In order to find an error of a concurrent program, one must examine every possible interleaving BUT leads to STATE EXPLOSION!
\end{itemize}
    

\end{frame}

\begin{frame} {Stateless Model Checking and Partial Order Reduction}
 
    
Partial order reduction aims to reduce the number of interleavings explored by eliminating the exploration of
equivalent interleavings.

For example:
\trace{../img/interleavings}{Examples of Interleavings}

\end{frame}

\begin{frame}{Stateless Model Checking and Partial Order Reduction}

\begin{itemize}[<+->]
\item Static Partial Order Reduction: Dependencies are tracked before execution.

\item Dynamic Partial Order Reduction: Dependencies are observed during runtime.
\end{itemize}

\end{frame}

\begin{frame}{Bounding Techniques for DPOR}

\begin{itemize}[<+->]
\item For larger programs DPOR often runs longer than developers are willing to wait. 
\item Bounded techniques, alleviate state-space explosion by pruning the executions
that exceed a bound. 
\item Preemption Bounded and Delay Bounded exploration.
\item Many of the concurrency bugs can be tracked even when the bound limit is set to be small.
\end{itemize}
    
\end{frame}

%% \subsection{Dynamic Partial Order Reduction}

\begin{frame}{General form of DPOR}
    
\SetKwProg{Fn}{Function}{}{}
\SetKwHangingKw{Let}{let}
\begin{figure}
\centering
\scalebox{1.}{
\begin{algorithm}[H]
    \caption{General form of DPOR}
    \label{GeneralDPOR}
    Explore($\emptyset$)\;
    \Fn{Explore($E$)}{
     \Let{$T = Sufficient\_set(final(E)$)}
     \For{all $t \in T$}{
        Explore($E.t$) \;
    }
    }
\end{algorithm}
}
\end{figure}

\end{frame}

\begin{frame}{The implemented DPOR form}

\begin{figure}
    
\scalebox{0.9}{
\SetKwProg{Fn}{Function}{}{}
\SetKwHangingKw{Let}{let}
\begin{algorithm}[H]
    \caption{Real DPOR Algorithm}
    \label{Source}
    Explore($\emptyset$)\;
    \Fn{Explore($E$)}{
        \If{suitable $p$ exists} {
            $backtrack(E):= \{p\}$ \;
            add to previous $backtracks$ threads due to dependencies revealed by $p$\;
            \While{$\exists p \in backtrack$}{
                $Explore(E.p)$ \;
            }
        }
    }
\end{algorithm}
}
\end{figure}

\end{frame}

\begin{frame}
\begin{definition}[Sufficient Sets]
A set of transitions is sufficient in a state $s$ if any relevant
state reachable via an enabled transition from $s$ is also reachable from $s$ via at least one of the transitions in the sufficient
set. A search can thus explore only the transitions in the
sufficient set from $s$ because all relevant states still remain
reachable. The set containing all enabled threads is trivially
sufficient in $s$, but smaller sufficient sets enable more state
space reduction.
\end{definition}
    
\end{frame}

\begin{frame}{Sufficient Sets: Persistent Sets}
    
\begin{definition}[Persistent Sets]
Let $s$ be a state, and let $W \subseteq E(s)$ be a set
of execution sequences from $s$. A set $T$ of transitions is a persistent set for $W$
after $s$ if for each prefix $w$ of some sequence in $W$, which contains no occurrence
of a transition in $T$,  we have $E \vdash t \diamondsuit w$ for each $t \in T$.
\end{definition}
\end{frame}

\begin{frame}{Sufficient Sets: Persistent Sets}
A simple example:
    
\trace{../img/persistent.pdf}{Construction of persistent sets}
    
\end{frame}

\begin{frame}{Sufficient Sets: Source Sets}

\begin{definition}[Initials after an execution sequence $E.w$, $I_{[E]}(w)$]
    $p \in I_{[E]}(w)$ if and only if there is a sequence $w'$ such that $E.w \simeq E.p.w'$.
\end{definition}


\begin{definition}[Weak Initials after an execution sequence $E.w$, $WI_{[E]}(w)$]
    $p \in WI_{[E]}(w)$ if and only if there are sequences $w'$ and $v$ such
that $E.w.v \simeq E.p.w'$.
\end{definition}
    
\end{frame}


\begin{frame}{Sufficient Sets: Source Sets}

\begin{definition}[Source Sets]
Let $E$ be an execution sequence,
and let $W$ be a set of sequences, such that $E.w$ is an execution
sequence for each $w \in W$. A set $T$ of processes is a source set for
$W$ after $E$ if for each $w \in W$ we have $WI_{[E]}(w) \cap T  \neq \emptyset$.
\end{definition}

\end{frame}

\begin{frame}{Source Sets}
An example:
\trace{../img/source.pdf}{Construction of Source Sets}
\end{frame}

\begin{frame}{Further Optimizations: Sleep Sets}
The idea behind Sleep Set Optimization:

\begin{itemize}
\item Assume that the search explores transition $t$ from state $s$, backtracks $t$, then explores $t_0$ from $s$ instead.
Unless the search explores a transition that is dependent with $t$, no states are reachable via $t_0$ that were not
already reachable via $t$ from s. Thus, $t$ ``sleeps'' unless a dependent transition is explored.
    
\end{itemize}
\end{frame}

\begin{frame}{Sleep Sets}
Sleep sets in action (Using Persistent Sets):
\trace{../img/sleep.pdf}{Example of Sleep Set Optimization}
\end{frame}


\begin{frame}{Bounded Dynamic Partial Order Reduction General Form}

Given a bound evaluation function $B_v$ and a bound $c$:

\begin{figure}
\scalebox{1.}{
\SetKwProg{Fn}{Function}{}{}
\begin{algorithm}[H]
    \caption{Bounded-DPOR}
    \KwResult{Explore the whole statespace}
    Explore($\emptyset$)\;
    \Fn{Explore($E$)}{

     $T = Sufficient\_set$($final(E)$)

     \For{all $t \in T$}{
         \If{$B_v(E.t) \leq c$}{
            Explore($E.t$)
         }
        }
    }
\end{algorithm}
}
\end{figure}
    
\end{frame}

\begin{frame}{Preemption Bounded Search}

\begin{definition}[Preemption bound]
$P_b(\emptyset) = 0$ \\
$P_b(E.t) = 
 \begin{cases} 
    P_b(E) + 1 & \text{ if } t.tid = last(E).tid \text{ and } last(E).tid \in enabled(final(E)) \\
    P_b(E) & \text{ otherwise }
 \end{cases}
$
\end{definition}
    
\end{frame}

\begin{frame}

\begin{definition}[$ext(s,t)$]
    Given a state $s = final(E)$ and a transition $t \in enabled(s)$,
    $ext(s,t)$ returns the unique sequence of transitions $\beta$ from $s$
    such that
    \begin{enumerate}
        \item $\forall i \in dom(\beta): \beta_i.tid = t.tid$
        \item $t.tid \notin enabled(final(E.\beta))$
    \end{enumerate}
\end{definition}
    
\end{frame}

\begin{frame}{Preemption Bounded Persistent Sets}

\begin{definition}[Preemption Bounded Persistent Set]

A set $T \subseteq \mathcal{T}$ of transitions enabled in a state $s=final(E)$
is preemption-bound persistent in $s$ iff for all nonempty
sequences $a$ of transitions from $s$ in $A_G(P_b,c)$ such that
$\forall i \in dom(a), a_i \notin T$ for all $t \in T$ ,

\begin{enumerate}
\item $Pb(E.t) \leq Pb(E.a_1)$
\item if $Pb(E.t)<Pb(E.a_{1}) ,$ then $t \leftrightarrow last(a)$ and $t \leftrightarrow  next(final(E.a), last(a).tid)$
\item if $Pb(E.t)=Pb(E.a_{1}),$ then $ext(s,t) \leftrightarrow last(a)$ and $ext(s,t) \leftrightarrow next(final(E.a), last(a).tid)$
\end{enumerate}

\end{definition}
    
\end{frame}

\begin{frame}{Preemption Bounded Persistent Sets}

Way simplified... :

\begin{itemize}[<+->]
   \item Add conservative branches at the beginning of the block.
   \item But what's a block?
\end{itemize}
   \pause
   \trace{../img/bound-persistent-blocks.pdf}{Example of Blocks and Bound Persistent Sets}
\end{frame}


\begin{frame}{Source-DPOR}

\begin{figure}
    
\scalebox{0.7}{
\SetKwProg{Fn}{Function}{}{}
\SetKwHangingKw{Let}{let}
\begin{algorithm}[H]
    \caption{Source-DPOR Algorithm}
    \label{Source}
    Explore($\langle \rangle$,$\emptyset$)\;
    \Fn{Explore($E$,$Sleep$)}{
        \If{$\exists p \in (enabled(s_{[E]}) \backslash Sleep)$}{
            $backtrack(E) :={p}$ \;
            \While{$\exists p \in (backtrack(E) \backslash Sleep)$}{
                \ForEach{$e \in dom(E)$ such that $e \lesssim_{E.p} next_{[E]}(p)$}{
                    \Let{$E' = pre(E,e)$}
                    \Let{$u = notdep(e,E).p$}
                    \If{$I_{E'}(u) \cap backtrack(E') = \emptyset$}{
                        add some $q' \in I_{[E']}(u) \text{ to } backtrack(E') $ \;
                    }
                }
                \Let{$Sleep' := \{q \in Sleep \mid E \models p \diamondsuit q \} $}
                $Explore(E.p, Sleep')$ \;
                add $p$ to $Sleep$ \;
            }
        }
    }
\end{algorithm}
}
\end{figure}

\end{frame}

\section{Implemented Algorithms}

%% \frame{\sectionpage}

\begin{frame}{Naive-BPOR}

\begin{figure}

\scalebox{.7}{
\begin{algorithm}[H]
    \SetKwInOut{Input}{input}
    \SetKwHangingKw{Let}{let}
    \SetKwProg{Fn}{Function}{}{}
    \caption{Naive-BPOR}
    \label{Vanilla}
    \SetKwInOut{Input}{input}
    Explore($\langle \rangle$,$\emptyset$,$b$)\;
    \Fn{Explore($E$,$Sleep$,$b$)}{
        \If{$\exists p \in (enabled(s_{[E]}) \backslash Sleep)$ such that $B_v(E.p) \leq b)$ }{
            $backtrack(E) :={p}$ \;
            \While{$\exists p \in (backtrack(E) \backslash Sleep$ and $B_v(E.p) \leq b$}{
                \ForEach{$e \in dom(E)$ such that $e \lesssim_{E.p} next_{[E]}(p) $}{
                    \Let{$E' = pre(E,e)$}
                    \Let{$u = notdep(e,E).p$}
                    \If{$I_{E'}(u) \cap backtrack(E') = \emptyset$}{
                        add some $q' \in I_{[E']}(u) to backtrack(E') $ \;
                    }
                }
                \Let{$Sleep' := \{q \in Sleep \mid E \models p \diamondsuit q \} $}
                $Explore(E.p, Sleep, b)$ \;
                add $p$ to $Sleep$ \;

            }
        }
    }
\end{algorithm}
    }
\end{figure}

\end{frame}

\begin{frame}{Example execution of Naive-BPOR}
    
A Naive-BPOR execution example and the problem with it.

\trace{../img/w2rvbound.pdf}{Naive-BPOR for bound=$0$}

\end{frame}

\begin{frame}{DPOR using Clock Vectors (Classic-DPOR)}

\begin{figure}
\scalebox{0.7}{
\begin{algorithm}[H]
    \caption{DPOR using Clock Vectors (Classic-DPOR)}
    \label{DPORV}
    \SetKwInOut{Input}{input}
    \SetKwInput{Initialization}{Explore($\emptyset, \lambda x. \bot$)}
    \SetKwHangingKw{Let}{let}
    \SetKwProg{Fn}{Function}{}{}
    \Fn{Explore($E$,$C$)}{
        \Let{$s := last(E)$}
        \For{all process $p$}{
            \If{$\exists i = max(\{ i \in dom(E) \mid E_i$ is dependent and may be co-enabled with $next(s,p)$ and $i \not \leq  C(p)(proc(E_i)) \} $}{
                \uIf{$p \in enabled(pre(E,i)))$}{
                    add $p$ to $backtrack(pre(E,i))$ \;
                }
                \Else{add $enabled(pre(E,i))$ to $backtrack(pre(E,i))$ \;}
            }
        }
        \If{$\exists p \in enabled(s)$}{
            $backtrack(s) := {p}$ \;
            \Let{$done = \emptyset$}
            \While{$\exists p \in (backtrack(s) \backslash done)$}{
               add $p$ to $done$ \;
               \Let{$t = next(s,p)$} 
                \Let{$E' = E.t$} 
                update vector clocks \;
                $Explore(E',C')$ \;
            }
        }
    }
\end{algorithm}
}
\end{figure}
\end{frame}

\begin{frame}{Source-DPOR vs Classic-DPOR}
Similarities:
\begin{enumerate}
    \item Consist of the same phases i.e., race detection and exploration
    \item Both rely on Vector Clocks.
\end{enumerate}

Differences:

\begin{enumerate}
    \item Classic-DPOR ``eager'' i.e., adds more dependencies before scheduling.
    \item Source-DPOR ``lazy'' i.e., adds branches after scheduling and thus avoids redundant additions.
\end{enumerate}

\end{frame}

\begin{frame}{Nidhugg-DPOR}
    
\begin{figure}
    
\scalebox{0.7}{
\begin{algorithm}[H]
    \caption{Nidhugg-DPOR}
    \label{NDPOR}
    \SetKwInOut{Input}{input}
    \SetKwHangingKw{Let}{let}
    \SetKwProg{Fn}{Function}{}{}
    Explore($\langle \rangle$,$\emptyset$)\;
    \Fn{Explore($E$,$Sleep$)}{
        \If{$\exists p \in (enabled(s_{[E]}) \backslash Sleep$}{
            backtrack(E) $:={p}$ \;
            \While{$\exists p \in (backtrack(E) \backslash Sleep)$}{
                \ForEach{$e \in dom(E)$ such that $e \lesssim_{E.p} next_{[E]}(p)$}{
                    \Let{$E' = pre(E,e)$}
                    \Let{$u = notdep(e,E).p$}
                    \Let{$CI = \{ i \in I_{E'}(u) \mid i \rightarrow p \}$}
                    \If{$CI \cap backtrack(E') = \emptyset$}{
                        \If{$CI \neq \emptyset$}{
                            add some $q' \in CI \text{ to } backtrack(E') $ \;
                        }
                        \Else{add some $q' I_{E'}(u) \text{ to } backtrack(E')$}
                    }
                }
                \Let{ $Sleep' := \{q \in Sleep \mid E \models p \diamondsuit q \} $ } 
                $Explore(E.p, Sleep)$ \;
                add $p$ to $Sleep$ \;
            }
        }
    }
\end{algorithm}
}
\end{figure}

\end{frame}

\begin{frame}{Correctness of Nidhugg-DPOR}


Case 1: At least one process contains a write command. We know that the two processes will be inverted at some
point. Since Nidhugg-DPOR ignores weak initials it will branch both processes. 
In Source-DPOR only one of the two processes should be branched since they share the same initials. 
However, in Nidhugg-DPOR this is not true since the $CI$ set does not contain steps from the other process.

\trace{../img/nidhuggpersistent1.pdf}{Construction of persistent sets in Nidhugg when there is a write process}

\end{frame}

\begin{frame}{Correctness of Nidhugg-DPOR}
    
Case 2: Both processes are read operations. Since we do not calculate $I$ but $CI$ the first read operation will not be
considered as it does not happen before the second read operation and as result both processes will be added to
$backtrack$.  We notice that by calculating the $CI$ set when the race between $p$ and $r$ is detected $q$ process will
be ignored and, thus, $r$ will be added as a branch.

\trace{../img/nidhuggpersistent.pdf}{Construction of persistent sets in Nidhugg when both are read processes}
    
\end{frame}



\begin{frame}{Nidhugg-BPOR}

\begin{figure}
    
\scalebox{0.9}{
\begin{algorithm}[H]
    \SetKwInOut{Input}{input}
    \SetKwHangingKw{Let}{let}
    \SetKwProg{Fn}{Function}{}{}
    \caption{Nidhugg-BPOR}
    \label{Nidhugg BPOR}
    \SetKwInOut{Input}{input}
    \SetKwHangingKw{Let}{let}
    Explore($\langle \rangle$,$\emptyset$,$b$)\;
    \Fn{Explore($E$,$Sleep$,$b$)}{
        \If{$\exists p \in ((enabled(s_{[E]}) \backslash Sleep)$ and $B_v(E.p) <=b$}{
            backtrack(E) $:={p}$ \;
            \While{$\exists p \in (backtrack(E) \backslash Sleep $ and $B_v(E.p) <=b$}{
                \ForEach{$e \in dom(E)$ such that $e \lesssim_{E.p} next_{[E]}(p)$}{
                    add non-conservative branches according to Persistent Sets \;
                    add conservative branches according to Persistent Sets at the beginning of blocks \;
                }
                \Let{ $Sleep' := \{q \in Sleep \mid E \models p \diamondsuit q \}$ } 
                $Explore(E.p, Sleep)$ \;
                \If{$p$ is not conservative}{
                    add $p$ to $Sleep$ \;
                }
            }
        }
    }
\end{algorithm}
}
\end{figure}
    
\end{frame}

\iffalse
\begin{frame}{Nidhugg-BPOR}

\begin{figure}
    
\scalebox{0.6}{
\begin{algorithm}[H]
    \SetKwInOut{Input}{input}
    \SetKwHangingKw{Let}{let}
    \SetKwProg{Fn}{Function}{}{}
    \caption{Nidhugg-BPOR}
    \label{Nidhugg BPOR}
    \SetKwInOut{Input}{input}
    \SetKwHangingKw{Let}{let}
    Explore($\langle \rangle$,$\emptyset$,$b$)\;
    \Fn{Explore($E$,$Sleep$,$b$)}{
        \If{$\exists p \in ((enabled(s_{[E]}) \backslash Sleep)$ and $B_v(E.p) <=b$}{
            backtrack(E) $:={p}$ \;
            \While{$\exists p \in (backtrack(E) \backslash Sleep $ and $B_v(E.p) <=b$}{
                \ForEach{$e \in dom(E)$ such that $e \lesssim_{E.p} next_{[E]}(p)$}{
                    \Let{$E' = pre(E,e)$}
                    \Let{$u = notdep(e,E).p$}
                    \Let{$CI = \{ i \in I_{E'}(u) \mid i \rightarrow p \}$}
                    \If{$CI \cap backtrack(E') = \emptyset$}{
                        \If{$CI \neq \emptyset$}{
                            add some $q' \in CI$ to $backtrack(E') $ \;
                        }
                        \Else{
                             add some $q' \in I_{[E']}(u)$ to $backtrack(E') $ \;}
                        }
                    \Let{$E''= pre\_block(e,E)$}
                    \Let{$u = notdep(e,E).p$}
                    \Let{$CI = \{ i \in I_{E''}(u) \mid i \rightarrow p \}$}
                    \If{$CI \cap backtrack(E') = \emptyset$}{
                        \If{$CI \neq \emptyset$}{
                            add some $q' \in CI$ to $backtrack(E') $ \;
                        }
                        \Else{
                            add some $c(q') \in I_{[E'']}(u)$ to $backtrack(E'') $ \;
                        }
                    } 
                }
                \Let{ $Sleep' := \{q \in Sleep \mid E \models p \diamondsuit q \}$ } 
                $Explore(E.p, Sleep)$ \;
                \If{$p$ is not conservative}{
                    add $p$ to $Sleep$ \;
                }
            }
        }
    }
\end{algorithm}
}
\end{figure}
    
\end{frame}
\fi


\begin{frame}{Source-BPOR: The main question}
Can we use source sets instead of Persistent Sets in order to implement BPOR?
\end{frame}

\begin{frame}{Source-BPOR: First approach}
We should use Source Sets for both conservative and non-conservative branches.

\trace{../img/w2rsourceconservative.pdf}{Following source sets for conservative branches}
    
\end{frame}

\begin{frame}{Source-BPOR: A Correct Approach}
    
We should use Source Sets for non-conservative branches and Persistent Sets for conservative branches.
\end{frame}

\iffalse
\begin{frame}{Source-BPOR}

\begin{figure}
\scalebox{0.6}{

\begin{algorithm}[H]
    \SetKwInOut{Input}{input}
    \SetKwHangingKw{Let}{let}
    \SetKwProg{Fn}{Function}{}{}
    \caption{Source-BPOR}
    \label{SBPOR}
    \SetKwInOut{Input}{input}
    \SetKwHangingKw{Let}{let}
    Explore($\langle \rangle$,$\emptyset$,$b$)\;
    \Fn{Explore($E$,$Sleep$,$b$)}{
        \If{$\exists p \in ((enabled(s_{[E]}) \backslash Sleep)$ and $B_v(E.p) <=b$}{
            backtrack(E) $:={p}$ \;
            \While{$\exists p \in (backtrack(E) \backslash Sleep $ and $B_v(E.p) <=b$}{
                \ForEach{$e \in dom(E)$ such that $e \lesssim_{E.p} next_{[E]}(p)$}{
                    \Let{$E' = pre(E,e)$}
                    \Let{$u = notdep(e,E).p$}
                    \If{$I_{E'}(u) \cap backtrack(E') = \emptyset$}{
                        add some $q' \in I_{[E']}(u) \text{ to } backtrack(E') $ \;
                    }
                    \Let{$E''= pre\_block(e,E)$}
                    \Let{$u = notdep(e,E).p$}
                    \Let{$CI = \{ i \in I_{E''}(u) \mid i \rightarrow p \}$}
                    \If{$CI \cap backtrack(E') = \emptyset$}{
                        \If{$CI \neq \emptyset$}{
                            add some $q' \in CI$ to $backtrack(E') $ \;
                        }
                        \Else{
                            add some $c(q') \in I_{[E'']}(u)$ to $backtrack(E'') $ \;
                        }
                    } 
                }
                \Let{ $Sleep' := \{q \in Sleep \mid E \models p \diamondsuit q \}$ } 
                $Explore(E.p, Sleep)$ \;
                \If{$p$ is not conservative}{
                    add $p$ to $Sleep$ \;
                }
            }
        }
    }
\end{algorithm}
}
\end{figure}

\end{frame}
\fi

\begin{frame}{Source-BPOR}

\begin{figure}
\scalebox{0.9}{

\begin{algorithm}[H]
    \SetKwInOut{Input}{input}
    \SetKwHangingKw{Let}{let}
    \SetKwProg{Fn}{Function}{}{}
    \caption{Source-BPOR}
    \label{SBPOR}
    \SetKwInOut{Input}{input}
    \SetKwHangingKw{Let}{let}
    Explore($\langle \rangle$,$\emptyset$,$b$)\;
    \Fn{Explore($E$,$Sleep$,$b$)}{
        \If{$\exists p \in ((enabled(s_{[E]}) \backslash Sleep)$ and $B_v(E.p) <=b$}{
            backtrack(E) $:={p}$ \;
            \While{$\exists p \in (backtrack(E) \backslash Sleep $ and $B_v(E.p) <=b$}{
                \ForEach{$e \in dom(E)$ such that $e \lesssim_{E.p} next_{[E]}(p)$}{
                    add non-conservative backtracks according to Source Sets \;
                    add conservative backtracks according to Persistent Sets at the beginning of blocks \;
                }
                \Let{ $Sleep' := \{q \in Sleep \mid E \models p \diamondsuit q \}$ } 
                $Explore(E.p, Sleep)$ \;
                \If{$p$ is not conservative}{
                    add $p$ to $Sleep$ \;
                }
            }
        }
    }
\end{algorithm}
}
\end{figure}

\end{frame}
\begin{frame}{Nidhugg-BPOR vs Source-BPOR}
Similarities:
\begin{itemize}
\item Same structure. 
\end{itemize}

Differences:
\begin{itemize}
    \item Source-BPOR relies on Source Sets for the addition of non-conservative branches while Nidhugg-BPOR relies on Persistent Sets.
\end{itemize}

    
\end{frame}


\begin{frame}{Challenges with Conservative Branches}
The usage of conservative branches leads to explosion of the state space:
    
\trace{../img/w3rbpor.pdf}{writer-3-readers explosion}

\end{frame}


\begin{frame}{Challenges with Conservative Branches}
Sleep Sets are no longer that useful:
    
\trace{../img/sleepsetproblem.pdf}{Sleep set contradiction}

\end{frame}


\begin{frame}{Concluding Remarks}
    
The Performance - Soundness Tradeoff: Some algorithms are faster but compromise the soundness of the exploration while
others are slower but sound as well.

\end{frame}

\begin{frame}{Nidhugg Implementation}
Nidhugg is a bug-finding tool which targets bugs caused by concurrency
and relaxed memory consistency in concurrent programs. It works on the
level of LLVM internal representation, which means that it can be used
for programs written in languages such as C or C++.
\end{frame}


\begin{frame}{The Nidhugg Flow Chart}
    
\mediumGraph{../img/flowchartv2.pdf}{Nidhugg's Flow Chart}

\end{frame}

\iffalse
\begin{frame}{Modifications in Nidhugg}
The implementation mainly is focused, as expected,  on see\_events() and add\_branches()
\end{frame}
\fi

\section{Evaluation}
%% \frame{\sectionpage}

\begin{frame}{Nidhugg-DPOR Evaluation}
Evaluation of Nidhugg-DPOR on Synthetic Tests
\graph{../img/wNr.png}{writer-N-readers}

\smalltabular{../tables/synthetic_unbounded.tex}{Source-DPOR vs Nidhugg-DPOR for Synthetic tests}
    
\end{frame}


\begin{frame}
Evaluation of Nidhugg-BPOR on Synthetic Tests
    
\graph{../img/wNrB.png}{writer-N-readers bounded}
\smalltabular{../tables/bounded.tex}{Traces for various bound limits}
    
\end{frame}

\begin{frame}{Evalution of BPOR on RCU}
Read-Copy-Update (RCU): Read-copy update (RCU) is a synchronization mechanism that was added to the Linux kernel in
October of 2002. 
    
Let's start with a small bound...

\bigtabular{../tables/naivevsbpor1.tex}{RCU results for bound $b=1$}

\end{frame}


\begin{frame}{Evalution of BPOR on RCU}

Let's increase the bound...
\bigtabular{../tables/naivevsbpor4.tex}{RCU results for bound $b=4$}

\end{frame}

\begin{frame}{Evalution of BPOR on RCU}
What did we achieve?

\bigtabular{../tables/dporvsbporpriority.tex}{Comparison between DPOR and BPOR}

\end{frame}

\begin{frame}{Equivalence of Source-BPOR with Nidhugg-BPOR}

    Equivalence Case1:

\trace{../img/equivalence_case1w.pdf}{Source-BPOR and Nidhugg-BPOR equivalence Case 1}
    
\end{frame}

\begin{frame}{Equivalence of Source-BPOR with Nidhugg-BPOR}
    Equivalence Case 2:
   \trace{../img/equivalence_case2.pdf}{Source-BPOR and Nidhugg-BPOR equivalence Case 2}
    
\end{frame}

\section{Further Discussion}
%% \frame{\sectionpage}

\begin{frame}{Motivation}
Some preemption-switches can be easily avoided. For example:

\trace{../img/motivation.pdf}{An example of avoidable preemption-switch}
    
\end{frame}

\begin{frame}{Alternating the General Form of BPOR}
What if calculate something more than the preemption-bound?
    
\begin{figure}
    
\scalebox{0.7}{
    \SetKwHangingKw{Let}{let}
    \SetKwProg{Fn}{Function}{}{}
\begin{algorithm}[H]
    \SetAlgoLined
    \caption{General form of the BPOR without branch addition}
    \label{NBBPOR}
    \KwResult{Explore the whole state space within the bound}
    Explore($\emptyset$)\;
    \Fn{Explore($S$)}{
        T = Sufficient\_set($final(S)$)
     \For{all $t \in T$}{
         \If{$min\{B_v([S.t])\} \leq c$}{
            Explore($S.t$)
         }
        }
    }
\end{algorithm}
}
\end{figure}
    
\end{frame}

\begin{frame}{Applying the Graph Construction Algorithm}

\trace{../img/compulsoryswitch.pdf}{Graph example}
    
\end{frame}

\begin{frame}{Introducing Lazy-BPOR}

\begin{figure}
    
\scalebox{0.7}{
\SetKwProg{Fn}{Function}{}{}
\SetKwHangingKw{Let}{let}
\begin{algorithm}[H]
    \caption{Lazy-BPOR}
    \label{Lazy-BPOR}
    \Let{$G =: \emptyset$}
    Explore($\langle \rangle$,$\emptyset$,$G$,$b$)\;
    \Fn{Explore($E$,$Sleep$,$G$,$b$)}{
        \If{$\exists p \in (enabled(s_{[E]}) \backslash Sleep)$ such that $B_v(E.p) \leq b$ }{
            backtrack(E) $:={p}$ \;
            \While{$\exists p \in (backtrack(E) \backslash Sleep $}{
                \ForEach{$e \in dom(E)$ such that $e \lesssim_{E.p} next_{[E]}(p) $}{
                    \Let{$E' = pre(E,e)$}
                    \Let{$u = notdep(e,E).p$}
                    \If{$I_{E'}(u) \cap backtrack(E') = \emptyset$}{
                        add some $q' \in I_{[E']}(u) to backtrack(E') $ \;
                    }
                }
                \Let{$Sleep' := \{q \in Sleep \mid E \models p \diamondsuit q \} $}
                \If{$p$ creates a new block}{
                    \Let{$block$ = $last\_block(E)$}
                    \Let{$G'$ = add\_block($block$,$G$)}
                }
                \If{$min \{ Ham\_path(G') \text{ which compensate with all happens-before relations of } E \} \leq b $}{
                    $Explore(E.p, Sleep,G',b)$ \;
                    add $p$ to $Sleep$ \;
                }
            }
        }
    }
\end{algorithm}
}
\end{figure}
    
\end{frame}

\begin{frame}{Evaluation of Lazy-BPOR}
Evaluation on Synthetic Tests:

\graph{../img/wNrLB.png}{writer-N-readers bounded by the first estimation algorithm}
\smalltabular{../tables/lazy1_bounded.tex}{Traces for the first estimation algorithm for various bound limits}
    
\end{frame}

\begin{frame}{Evaluation of Lazy-BPOR}

Evaluation on RCU (DPOR vs Lazy-BPOR):
\bigtabular{"../tables/lazy_buged_comp.tex"}{Comparison between DPOR and Lazy-BPOR}

\end{frame}

\begin{frame}{Evaluation of Lazy-BPOR}

Evaluation on RCU (Nidhugg-BPOR vs Lazy-BPOR):
\bigtabular{"../tables/hline_pandas_lazy_preep.tex"}{Comparison between BPOR and Lazy-BPOR}

\end{frame}

\begin{frame}
Conclusion:

\begin{itemize}[<+->]
    \item It is possible to explore a preemption-bounded state space without the addition of conservative branches.
    \item It provides an upper bound for the number of traces explored in BPOR no matter the bound. In fact the number
    of traces explored by Lazy-BPOR at worst case equal to the number of traces explored by the unbounded DPOR. This is
    true since no conservative branches are added.
    \item The most important is that it provides a reduction of the preemption-bounded search to a well known graph problem where many heuristics can
    be applied in order to expedite the calculation of the minimum hamiltonian path.
\end{itemize}
    
\end{frame}

\begin{frame}{Bibliography}
    \begin{itemize}
        \item Abdulla P, Aronis S., Jonsson B., Sagonas K. (2014) Optimal Dynamic Partial Order Reduction
        \item Coons K., Musuvathi M, McKinley K., (2013) Bounded Partial-Order Reduction 
        \item Kokologiannakis M, Sagonas K., (2017) Stateless Model Checking of the Linux Kernel’s Hierarchical Read-Copy-Update (Tree RCU)
        \item Thomson P., Donaldson A., Betts A., (2016) Testing Using Controlled Schedulers: An Empirical Study
        \item Flanagan C., Godefroid P. (2005) Dynamic Partial-Order Reduction for Model Checking Software 
    \end{itemize}
    
\end{frame}

\begin{frame}
    Thank you for your attention!
\end{frame}

\begin{frame}{Nidhugg-BPOR (Detailed)}

\begin{figure}
    
\scalebox{0.6}{
\begin{algorithm}[H]
    \SetKwInOut{Input}{input}
    \SetKwHangingKw{Let}{let}
    \SetKwProg{Fn}{Function}{}{}
    \caption{Nidhugg-BPOR}
    \label{Nidhugg BPOR}
    \SetKwInOut{Input}{input}
    \SetKwHangingKw{Let}{let}
    Explore($\langle \rangle$,$\emptyset$,$b$)\;
    \Fn{Explore($E$,$Sleep$,$b$)}{
        \If{$\exists p \in ((enabled(s_{[E]}) \backslash Sleep)$ and $B_v(E.p) <=b$}{
            backtrack(E) $:={p}$ \;
            \While{$\exists p \in (backtrack(E) \backslash Sleep $ and $B_v(E.p) <=b$}{
                \ForEach{$e \in dom(E)$ such that $e \lesssim_{E.p} next_{[E]}(p)$}{
                    \Let{$E' = pre(E,e)$}
                    \Let{$u = notdep(e,E).p$}
                    \Let{$CI = \{ i \in I_{E'}(u) \mid i \rightarrow p \}$}
                    \If{$CI \cap backtrack(E') = \emptyset$}{
                        \If{$CI \neq \emptyset$}{
                            add some $q' \in CI$ to $backtrack(E') $ \;
                        }
                        \Else{
                             add some $q' \in I_{[E']}(u)$ to $backtrack(E') $ \;}
                        }
                    \Let{$E''= pre\_block(e,E)$}
                    \Let{$u = notdep(e,E).p$}
                    \Let{$CI = \{ i \in I_{E''}(u) \mid i \rightarrow p \}$}
                    \If{$CI \cap backtrack(E') = \emptyset$}{
                        \If{$CI \neq \emptyset$}{
                            add some $q' \in CI$ to $backtrack(E') $ \;
                        }
                        \Else{
                            add some $c(q') \in I_{[E'']}(u)$ to $backtrack(E'') $ \;
                        }
                    } 
                }
                \Let{ $Sleep' := \{q \in Sleep \mid E \models p \diamondsuit q \}$ } 
                $Explore(E.p, Sleep)$ \;
                \If{$p$ is not conservative}{
                    add $p$ to $Sleep$ \;
                }
            }
        }
    }
\end{algorithm}
}
\end{figure}
    
\end{frame}

\begin{frame}{Source-BPOR (Detailed)}

\begin{figure}
\scalebox{0.6}{

\begin{algorithm}[H]
    \SetKwInOut{Input}{input}
    \SetKwHangingKw{Let}{let}
    \SetKwProg{Fn}{Function}{}{}
    \caption{Source-BPOR}
    \label{SBPOR}
    \SetKwInOut{Input}{input}
    \SetKwHangingKw{Let}{let}
    Explore($\langle \rangle$,$\emptyset$,$b$)\;
    \Fn{Explore($E$,$Sleep$,$b$)}{
        \If{$\exists p \in ((enabled(s_{[E]}) \backslash Sleep)$ and $B_v(E.p) <=b$}{
            backtrack(E) $:={p}$ \;
            \While{$\exists p \in (backtrack(E) \backslash Sleep $ and $B_v(E.p) <=b$}{
                \ForEach{$e \in dom(E)$ such that $e \lesssim_{E.p} next_{[E]}(p)$}{
                    \Let{$E' = pre(E,e)$}
                    \Let{$u = notdep(e,E).p$}
                    \If{$I_{E'}(u) \cap backtrack(E') = \emptyset$}{
                        add some $q' \in I_{[E']}(u) \text{ to } backtrack(E') $ \;
                    }
                    \Let{$E''= pre\_block(e,E)$}
                    \Let{$u = notdep(e,E).p$}
                    \Let{$CI = \{ i \in I_{E''}(u) \mid i \rightarrow p \}$}
                    \If{$CI \cap backtrack(E') = \emptyset$}{
                        \If{$CI \neq \emptyset$}{
                            add some $q' \in CI$ to $backtrack(E') $ \;
                        }
                        \Else{
                            add some $c(q') \in I_{[E'']}(u)$ to $backtrack(E'') $ \;
                        }
                    } 
                }
                \Let{ $Sleep' := \{q \in Sleep \mid E \models p \diamondsuit q \}$ } 
                $Explore(E.p, Sleep)$ \;
                \If{$p$ is not conservative}{
                    add $p$ to $Sleep$ \;
                }
            }
        }
    }
\end{algorithm}
}
\end{figure}
\end{frame}

\begin{frame}{Classic-BPOR}
    
\begin{figure}
\scalebox{0.6}{
\begin{algorithm}[H]
    \SetKwInOut{Input}{input}
    \SetKwHangingKw{Let}{let}
    \SetKwProg{Fn}{Function}{}{}
    \caption{BPOR}
    \label{BPOR}
    \SetKwInput{Initialization}{Explore($ \emptyset $)}
    \Fn{Explore($E$)}{
        \Let{$s := last(E)$}
        \For{all process $p$}{
            \For{all process $q \neq p$}{
            \If{$\exists i = max(\{ i \in dom(E) \mid E_i$ is dependent and may be co-enabled with $next(s,p)$ and $ E_i.tid = q \} $}{
                \uIf{$p \in enabled(pre(E,i)))$}{
                    add $p$ to $backtrack(pre(E,i))$ \;
                }
                \Else{add $enabled(pre(E,i))$ to $backtrack(pre(E,i))$ \;}
                \uIf{$j = max(\{ j \in dom(E) \mid j = 0 $ or $ S_{j-1}.tid \neq S_j.tid $ and $ j<i \})$}{
                    \uIf{$p \in enabled(pre(E,i)))$}{
                        add $p$ to $backtrack(pre(E,i))$ \;
                    }
                    \Else{add $enabled(pre(E,i))$ to $backtrack(pre(E,i))$ \;}
                }
            }
            }
        }
        \If{$p \in enabled(s)$}{
            add $p$ to $backtrack(s)$ \;
        }
        \Else{
            add any $u \in enabled(s)$ to $backtrack(s)$ \;
        }
        \Let{$visited = \emptyset $}
        \While{$ \exists u \in (enabled(s) \cap backtrack(s) \backslash visited) $}{
            add $u$ to $visited$ \;
            \uIf{$(B_v(S.next(s, u)) \leq c)$}{
                Explore($S.next(s, u)$) \;
            }
        }
    }
\end{algorithm}
}
\end{figure}

\end{frame}
\end{document} 
